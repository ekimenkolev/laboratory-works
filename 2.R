rm(list=ls())
setwd("C:/R_labs/Probabilistic models/")
#Variant 	p_11	p_12	p_13	p_21	p_22	p_23	p_31	p_32	p_33
#20		     0.1	0.6	  0.3	  0.1	  0.5	  0.4	  0.3 	0.4 	0.3

# матрица переходных вероятностей 
M = t(matrix(c(0.1,	0.6,	0.3,
             0.1,	0.5,	0.4,
             0.3,	0.4,	0.3),3,3))
M
# 1) По критерию эргодичности найти стационарное распределение
#    π = {π1, π2, π3}.

pi(e) - вероятность быть в состоянии e на текущем шаге
# искомый предельный вектор
# pi = [pi1, pi2, pi33]

# составим слау основываясь на критерии эргодичности для поиска предельного вектора
E <- t(matrix(c(1,0,0,0,1,0,0,0,1),3,3))
#matrix кэфы системы, 1 уравнение из системы выкидываем для нахождения решения
K <- t(matrix(c(1,1,1,t(t(M[,2:3]) - E[2:3,])),3,3))  
B <- matrix(c(1,0,0),3,1) #правая часть слау

pi<-t(solve(K,B))

# 2) Для нескольких начальных распределений P(0) = {p1, p2, p3} 
# смоделировать изменения состояния цепи за n = 10 000 шагов, 
# оценить вероятности попадания в каждое из состояний,
# сравнить со стационарным распределением.
# Оценить скорость сходимости к стационарному распределению на основе расстояния
# P_10^i − pi, i = 1,..,4, где P_10^i – оценка распределения цепи на шаге 10^i

# вектор начального распределения
# вектор вероятности цепи Маркова на шаге 1
p = c( 1/3, 1/3, 1/3)

# произвольно выбираем следующий путь
nextStep = function(p) {
  luck = runif(1,0,1);
  if(luck <= p[1]) {
    return(1)
  } else if(luck <= p[1]+p[2]) {
    return(2)
  } else {
    return(3)
  }
}

# начальное положение в цепи
state = nextStep(p);
# оценить скорость сходимости к стационарному распределению на основе расстояния
steps = c(10, 100, 1000, 10000)
graph = runif(length(steps),0,0)

# Евклидово расстояние
euclidean <- function (a, b){
  return(sqrt ( sum ((a - b)^2)))
} 

# текущий шаг 
cur_n = 1;
count = c(0,0,0)
for (j in 1:10000) {
  state = nextStep(M[state,])
  # считаем частоту попаданий в каждое состояние
  count[state] = count[state] + 1
  # Оценить скорость сходимости к стационарному распределению на основе расстояния
  # P_10^i − pi, i = 1,..,4, где P_10^i – оценка распределения цепи на шаге 10^i
  if (j == steps[cur_n]) {
    pr = c(0,0,0)
    for (g in 1:3) {
      # вероятности попадания в каждое состояние за 10, 100, 1000, 10000 шагов
      pr[g] = count[g]/steps[cur_n]
    }
    #print(euclidean(empR, pi))
    graph[cur_n] = euclidean(pr, pi)
    cur_n = cur_n + 1
  }
}

plot(x = steps, graph[], type = "l", col = "purple")

# изменения состояния цепи за 10 000 шагов
print(pr)
# стационарная точка
print(pi)
#  Вывод: для цепи Маркова при возрастании числа шагов n вектор вероятностей
# принимает постоянное значение pi, которое называется предельным,
# который является в свою очередь стационарным распределением вероятностей для
# цепи Маркова с матрицей перехода М

# 3) ) Для нескольких начальных распределений оценить n* - время релаксации –
# минимальное число шагов, на котором распределение цепи удовлетворяют
# свойству


# 3
# Эпсилон
e = 0.001
#число прогонов
k = 10

p <- c(0,0,0)
p_list = list()
# для нескольких начальных распределений
for (ki in 1:k) {
  # начальные распределения
  p[1] = runif(1,0,1)
  p[2] = runif(1,0,1-p[1])
  p[3] = 1-p[1]-p[2]
  p <- c(p[1],p[2],p[3])
  p_list[[ki]] = p
  cat('sum', ki,'=',p[1] + p[2] + p[3])
}

# для нескольких начальных распределений
for (ki in 1:k) {
  cur_p = p_list[[ki]]%*%M;
  
  for (j in 1:100000){
    if (euclidean(cur_p, pi) < e) {
      print("время релаксаци, вероятность, евклидово расстояние:")
      print(j)
      print(cur_p)
      print(euclidean(cur_p,pi))
      break
    }
    cur_p = cur_p%*%M
  }
}
