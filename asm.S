*

	    Подпрограммы и соглашения о связях
	*/
.include "my-macro" # подключение файла с макроопределениями

.data 			# секция данных, распределение памяти
n:	.long 0

Symbols:
	.asciz  "91A23B456C789" # массив символьных кодов
	#                                  цифр и "не цифр"

.bss    		# секция общей памяти (для результата)

.lcomm  Numbers, 40	# массив 4-х байтовых значений цифр

.text 		# секция команд процесора

.type   Read_Sym, @function # функция циклической обработки массива, читает соответствующий символ

Read_Sym:

	/*
	        Читает <Параметр1> символов из массива <Параметр2>
	        и передает их на обработку функции Trans_Sym.
	        Результат размещается в массив Numbers
	*/
##        Стандартный пролог фунции

	pushl %ebp			# сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp 	# обеспечить адресный доступ к параметрам и( дублируем значение стека)
						##  локальным переменнным в стеке путем базовой
						##  адресации через ebp
	subl  $4, %esp			# завести 4-х байтовую локальную переменную (отнимаем 4)выделили место для значения
	movl  $0xdadadada,%eax 	#чтобы мы смогли отслеживать наши изменения
	movl  $0,-4(%ebp) 		# (позиция,куда мы пришли) -4 байта, 0, потому что записывать в лок переменную кол-во нецифровых чисел
	mov   $0xfefefefe,%eax
##        Тело функции
	subl %ecx, %ecx   		# инициализация счетчика цикла (обнуление )
NextSym:
	movl 12(%ebp), %edx 	# адрес второго параметра-массива в edx

##        вызов функции Trans_Sym



	subl %ebx, %ebx	# подготовка ebx для записи символа
	movb (%edx,%ecx,1), %bl	# символ в ebx(ecx = 0)
	cmpb $'9', %bl	# код больше кода символа '9' ?
	ja not_digit    # ДА - на вывод сообщения об ошибке
	cmpb $'0', %bl  # код меньше кода символа '0' ?
	jb not_digit
	
##        Начинаем вызов Trans_Sym

	pusha   	# сохранить регистры текущей функции Read_Sym

	pushl %ebx	# Параметр функции Trans_Sym (код
				##  символа из массива) в стек (символ, который мы прочитали) ebx,так как 4 байта
	call Trans_Sym

	addl    $4,%esp	# очистить стек от параметров Trans_Sym(исчезнет параметр ebx)

	movl    %eax, Numbers(,%ecx,4) # записать результат Trans-Sym(размещенный в eax) в массив Numbers(по 4 байта на 1 символ)

	popa   		# восстановить регистры Read_Sym

	jmp next
	
not_digit:
	incl -4(%ebp)		#переход, когда не цифровая клавиша (-4- локальная переменная, увелич на 1)
next:
	incl %ecx	# наращиваем счетчик цикла
	cmpl 8(%ebp), %ecx # счетчик равен первому параметру?(пока 8 раз не прочитаем символы)
	jne NextSym	# ДА, повторяем
	##  НЕТ - выходим из цикла

##        Стандартный эпилог функции
	movl -4(%ebp), %eax	#значение локальной в еах
	movl %ebp, %esp # восстановить указатель стека
	popl %ebp	# восстановить ebp
	ret	# возврат в вызывающую (readSym)


##  конец Read_Sym

	/*
	    Функция преобразования кода символа в числовое значение
	<Пареметр1> преобразуется в число и возвращается в eax */

	.type   Trans_Sym, @function

Trans_Sym:

##        Стандартный пролог фунции

	pushl %ebp	# сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp 	# обеспечить адресный доступ к параметрам и
						##  локальным переменнным в стеке путем базовой
						##  адресации через ebp

##        тело функции

	movl 8(%ebp), %eax # параметр в eax
	subl $0x30, %eax # получение числового значения 

##        Стандартный эпилог функции

	movl %ebp, %esp # восстановить указатель стека
	popl %ebp       # восстановить ebp
	ret	# возврат в вызывающую


	.global _start 		# точка входа - глобальная метка

_start:

	nop

	pusha   			# сохранение регистров главной программы
	pushl $Symbols  	# Параметр-2 - адрес массива в стек
	pushl $8 			# Параметр-1 в стек

	call Read_Sym # вызов функции, записывает адрес сл команды в стек(адрес 4 байта)
	movl %eax, n
	addl $8,%esp # очистить стек от параметров Read_Sym( так как у нас было два параметра по 4 байта)
	popa	# восстановить регистры главной програмы

	Exit $0 	# конец работы, возврат в ОС (макро из файла my-macro)
	.end		# последняя строка исходного текста
